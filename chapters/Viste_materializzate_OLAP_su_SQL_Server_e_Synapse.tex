\chapter{Viste materializzate OLAP su SQL Server e Synapse}

Questo capitolo tratterà dell’implementazione, dell’impiego da parte dell’ottimizzatore e del monitoraggio delle viste materializzate in Azure Synapse – Dedicated SQL Pool e delle viste indicizzate in Microsoft SQL Server, con riferimento a carichi OLAP su \textit{data warehouse} e in continuità con le scelte fisiche illustrate nel Capitolo \ref{cap4} e con i criteri di selezione/manutenzione formalizzati nel Capitolo \ref{cap5} (Vaisman \& Zimányi, 2022 \cite{VaismanZimanyi2022}; Microsoft, 2024–2025 \cite{Microsoft2024-2025}). 
\\ \\
Lo scopo è tradurre i principi teorici in procedure operative riproducibili, definendo come creare correttamente gli oggetti, come abilitare il \textit{query rewrite} e come governarne la manutenzione in presenza di aggiornamenti, con misure che rendano verificabile il rapporto tra beneficio prestazionale e costo gestionale (Vaisman \& Zimányi, 2022 \cite{VaismanZimanyi2022}; Microsoft, 2024–2025 \cite{Microsoft2024-2025}). 
\\ \\
L’approfondimento si atterrà strettamente a funzionalità e vincoli così come documentati nelle fonti ufficiali e nella letteratura. La verifica sperimentale utilizzerà un sottoinsieme del \textit{workload} TPC-DS per ancorare i risultati a uno \textit{standard} pubblico, e farà ricorso esclusivo a strumenti nativi (piani di esecuzione/EXPLAIN, DMV, comandi DBCC per la stima dell’\textit{overhead} e l’eventuale REBUILD), evitando proposte euristiche non supportate (TPC, 2021 \cite{TPC2021}; Microsoft, 2024–2025 \cite{Microsoft2024-2025}). 
\\ \\
Questo approfondimento si limita al SQL relazionale dei due motori considerati; sono pertanto esclusi linguaggi per cubi (ad esempio: MDX) e tecnologie non pertinenti. La ricerca si concentra unicamente alla messa in pratica documentata di viste materializzate/viste indicizzate e alla loro valutazione misurata sul caso d’uso adottato (Vaisman \& Zimányi, 2022 \cite{VaismanZimanyi2022}; Microsoft, 2024–2025 \cite{Microsoft2024-2025}). 
\\ \\
Per gli esempi e per la validazione empirica si fa riferimento al \textit{workload} TPC-DS, ampiamente utilizzato in letteratura per rappresentare scenari OLAP con numerose \textit{join} e aggregazioni a diverse granularità. L’impiego di TPC-DS consente di ancorare i risultati a uno \textit{standard} pubblico, garantendo confrontabilità e riproducibilità delle misure. La verifica dei benefici e dei costi è svolta con strumenti nativi: analisi dei piani di esecuzione (EXPLAIN, incluse le raccomandazioni in Synapse), interrogazione delle \textit{Dynamic Management Views} (DMV) e utilizzo dei comandi DBCC per stimare l’\textit{overhead} di manutenzione e pianificare eventuali REBUILD. (TPC, 2021 \cite{TPC2021}; Microsoft, 2024–2025 \cite{Microsoft2024-2025}).

\section{Implementazione in SQL Server e Azure Synapse}

\subsection{Indexed views (SQL Server) e Materialized views (Synapse)}

Nel quadro di un \textit{data warehouse} OLAP, SQL Server e Azure Synapse (Dedicated SQL Pool) implementano la materializzazione con modelli differenti ma finalità coincidenti: precalcolare e memorizzare i risultati di \textit{join} e aggregazioni per ridurre latenza e I/O su interrogazioni ripetitive. In SQL Server la materializzazione è ottenuta tramite viste indicizzate: una vista definita con vincoli formali stringenti (\ref{sec:612}) diventa fisicamente persistita non appena si crea il primo indice \textit{cluster} univoco; da quel momento, l’ottimizzatore può impiegarla anche senza riferimento esplicito nel testo SQL, sostituendo sotto‐piani di \textit{join}/aggregazione con accessi all’oggetto materializzato quando il costo stimato lo giustifica. Tale meccanismo, documentato nelle linee guida ufficiali, dipende dalla corretta impostazione delle opzioni SET, dal determinismo delle espressioni e dalla compatibilità semantica tra la \textit{query} e la vista (Microsoft, 2024–2025 \cite{Microsoft2024-2025}; Vaisman \& Zimányi, 2022 \cite{VaismanZimanyi2022}). 

\includesql{./adds/Viste_materializzate_OLAP_su_SQL_Server_e_Synapse/Esempio_T-SQL_(SQL_Server_vista_indicizzata)}{Vista indicizzata con SCHEMABINDING e indice \textit{cluster} univoco in SQL Server (esempio originale)}{lst:Vista_indicizzata_SCHEMABINDING_indice_cluster_univoco_SQL_Server}

In Synapse, invece, la materializzazione è un oggetto nativo creato con CREATE MATERIALIZED VIEW ... AS SELECT ..., archiviato in \textit{columnstore} e dotato di una distribuzione (HASH o ROUND\_ROBIN) che ne determina il comportamento in un ambiente MPP. L’ottimizzatore può eseguire un \textit{query rewrite} automatico, servendo una \textit{query} dalla vista anche in assenza di citazione esplicita, purché la definizione catturi un’aggregazione e un insieme di \textit{join} compatibili con il sotto‐piano richiesto; il controllo avviene tramite analisi del piano stimato/EXPLAIN, come discusso in \ref{sec:613} (Microsoft, 2023–2024)\cite{Microsoft2023-2024}. Rispetto a SQL Server, Synapse enfatizza la co‐locazione dei dati tramite distribuzione HASH per ridurre gli \textit{shuffle} in fase di \textit{join} e favorire piani più stabili sul carico analitico (Vaisman \& Zimányi, 2022)\cite{VaismanZimanyi2022}. 
\\ \\
Dal punto di vista concettuale (come discusso nel Capitolo \ref{cap5}), entrambi i motori implementano la stessa idea generale di vista materializzata: una valutazione precalcolata di espressioni relazionali che bilancia i benefici in lettura con i costi di manutenzione generati dai DML sulle tabelle di base. La letteratura sottolinea che questo “\textit{maintenance problem}” (cioè quanto, quando e come aggiornare gli oggetti materializzati) è il cuore del compromesso progettuale e spiega la presenza, nelle implementazioni industriali, di vincoli e procedure atte a garantire correttezza e prevedibilità (Chirkova \& Yang, 2012 \cite{ChirkovaYang2011}; Vaisman \& Zimányi, 2022 \cite{VaismanZimanyi2022}). Riassumendo, viste indicizzate (SQL Server) e \textit{materialized views} (Synapse) convergono su un medesimo obiettivo: riutilizzare risultati condivisi per stabilizzare le latenze delle \textit{query} OLAP, delegando all’ottimizzatore l’uso trasparente quando le condizioni semantiche e fisiche lo consentono. (Microsoft, 2023–2025 \cite{Microsoft2023-2025}; Chirkova \& Yang, 2012 \cite{ChirkovaYang2011}; Vaisman \& Zimányi, 2022 \cite{VaismanZimanyi2022}).

\subsection{Requisiti e vincoli per la creazione di viste materializzate}\label{sec:612}

Nel caso di SQL Server, la materializzazione avviene tramite viste indicizzate e impone una serie di condizioni formali non negoziabili. La vista deve essere definita con SCHEMABINDING, in modo da vincolare lo schema delle tabelle sottostanti. Tutte le espressioni utilizzate devono essere deterministiche, in presenza di raggruppamenti è richiesto COUNT\_BIG(*) per garantire correttezza e manutenibilità. Durante la creazione e utilizzo devono essere attive specifiche opzioni SET (ad esempio ANSI\_NULLS ON, QUOTED\_IDENTIFIER ON, ARITHABORT ON, ecc.). Infine, il primo indice creato sulla vista deve essere un \textit{unique clustered index}, prerequisito che abilita la persistenza fisica e l’eventuale impiego trasparente da parte dell’ottimizzatore anche senza citazione esplicita della vista nel testo SQL. Tali vincoli (insieme ad ulteriori restrizioni su costrutti non supportati) sono documentati nella guida ufficiale e mirano a rendere sicura la manutenzione incrementale e l’ottimizzazione dei piani. (Microsoft, 2025)\cite{Microsoft2025}. 

\includesql{./adds/Viste_materializzate_OLAP_su_SQL_Server_e_Synapse/Synapse_materialized_view_REBUILD_DISTINCT}{Synapse: \texttt{CREATE MATERIALIZED VIEW} con \texttt{DISTRIBUTION = HASH} e REBUILD (esempio originale)}{lst:Synapse_CREATE_MATERIALIZED_VIEW_REBUILD}

Per Azure Synapse (Dedicated SQL Pool), le \textit{materialized views} sono oggetti nativi creati con l’istruzione CREATE MATERIALIZED VIEW ... AS SELECT ... e richiedono la scelta esplicita della distribuzione: HASH su una o più chiavi consente co-locazione e riduzione del \textit{data movement}, mentre ROUND\_ROBIN opera come distribuzione neutra e si adotta tipicamente in assenza di chiavi naturali o in scenari transitori. Il formato di archiviazione è \textit{columnstore} e la definizione non può referenziare altre viste. La documentazione segnala inoltre che alcune aggregazioni non sono ammesse in definizione (ad esempio COUNT(DISTINCT)), pur potendo l’ottimizzatore riscrivere \textit{query} che le includono servendosi di una \textit{materialized view} compatibile. Sono previsti, infine, aspetti di \textit{ownership}/permessi e operazioni di REBUILD per contenere l’\textit{overhead} in presenza di intensi aggiornamenti. (Microsoft, 2023 \cite{Microsoft2023}; Microsoft, 2022–2023 \cite{Microsoft2022-2023}). 
\\ \\
Il razionale OLAP che giustifica questi requisiti è duplice. Da un lato, vincoli come SCHEMABINDING, determinismo e chiavi univoche (SQL Server) o una distribuzione coerente con le chiavi di \textit{join} (Synapse) consentono al motore di riconoscere in modo affidabile i sotto-piani di \textit{join} e aggregazione dell’interrogazione e di sostituirli con risultati precalcolati. Dall’altro, tali vincoli limitano il costo di manutenzione incrementale al variare dei dati, che rimane l’elemento critico di ogni strategia di materializzazione. In termini pratici, nelle gerarchie di \textit{roll-up} tipiche dei d\textit{ata warehouse} (giorno→mese→anno; prodotto→categoria) la definizione di viste deterministiche e allineate alla distribuzione riduce lo \textit{shuffle} e stabilizza le latenze, purché si monitorino periodicamente statistiche e \textit{overhead} e si pianifichino eventuali REBUILD nelle finestre ETL. Queste scelte sono coerenti con le linee guida industriali e con l’inquadramento accademico della progettazione fisica dei \textit{data warehouse}. (Vaisman \& Zimányi, 2022 \cite{VaismanZimanyi2022}; Microsoft, 2022–2025 \cite{Microsoft2022-2025}).  

\subsection{Utilizzo da parte dell’ottimizzatore}\label{sec:613}

Nel Dedicated SQL Pool di Azure Synapse l’ottimizzatore può effettuare una riscrittura automatica delle interrogazioni, sostituendo porzioni di piano con accessi a \textit{materialized views} semanticamente compatibili anche in assenza di un riferimento esplicito alla vista nel testo SQL. La verifica operativa di tale comportamento si esegue tramite EXPLAIN, eventualmente con l’opzione WITH RECOMMENDATIONS, che restituisce il piano stimato, evidenziando operatori, movimenti dati e, quando pertinente, suggerimenti o utilizzi di viste materializzate idonee (Microsoft, 2024a)\cite{Microsoft2024a}. In termini pratici, l’effettivo \textit{matching} richiede che la definizione della vista catturi il sotto-piano di \textit{join} e aggregazione della \textit{query}, con colonne, filtri e granularità coerenti. In presenza di predicati più selettivi, l’ottimizzatore può comunque riutilizzare l’aggregato e applicare i filtri a valle, purché la correttezza semantica sia preservata. L’assenza di riferimenti ad altre viste nella definizione, il rispetto dei vincoli espressi in \ref{sec:612} e la disponibilità di statistiche aggiornate aumentano la probabilità di riscrittura. Al contrario, differenze strutturali, uso di funzioni non supportate o stato di manutenzione degradato della vista ne limitano l’impiego. L’analisi dei piani consente quindi di accertare non solo la scelta della \textit{materialized view} ma anche l’eventuale eliminazione di \textit{shuffle} su \textit{join} ripetitivi, aspetto che nei carichi OLAP incide in modo determinante sulla latenza complessiva (Microsoft, 2024a)\cite{Microsoft2024a}. 

\includesql{./adds/Viste_materializzate_OLAP_su_SQL_Server_e_Synapse/SQL_Server_NOEXPAND_EXPAND_VIEWS}{SQL Server: controllo dell’uso di viste indicizzate con \texttt{NOEXPAND} / \texttt{EXPAND VIEWS} (esempio originale)}{lst:SQL_Server_NOEXPAND_EXPAND VIEWS}

Nel caso di SQL Server, le viste indicizzate possono essere selezionate dall’ottimizzatore anche senza menzione esplicita quando il costo stimato lo giustifica e quando sono soddisfatti i requisiti formali della vista e delle opzioni SET associate. In specifici scenari è tuttavia possibile orientare la scelta del piano mediante \textit{hint}. L’\textit{hint} di tabella NOEXPAND evita che la vista venga espansa sulle tabelle sottostanti, inducendo l’uso dell’indice materializzato collegato. Dall’altro lato, l’\textit{hint} di \textit{query} EXPAND VIEWS forza l’espansione e inibisce l’impiego della vista indicizzata (Microsoft, 2025a)\cite{Microsoft2025}. L’uso degli \textit{hint} va limitato a casi mirati, ad esempio per analisi “\textit{what-if}”, per mitigare regressioni di piano o in edizioni/configurazioni in cui il motore non consideri automaticamente la vista. Questo perché viene introdotta una dipendenza esplicita dalla scelta del piano che potrebbe non generalizzare a versioni, statistiche o carichi diversi (Microsoft, 2025a \cite{Microsoft2025a}; Microsoft, 2025b \cite{Microsoft2025b}). In sintesi, la strategia consigliata in entrambi i motori è osservazionale e misurativa: progettare e mantenere correttamente la vista, verificare con EXPLAIN/piano di esecuzione l’effettivo \textit{rewrite} o \textit{matching} e intervenire con \textit{hint} solo come \textit{extrema ratio}, seguendo le pratiche documentate (Microsoft, 2024a \cite{Microsoft2024a}; Microsoft, 2025a \cite{Microsoft2025a}; Microsoft, 2025b \cite{Microsoft2025b}).

\subsection{Ottimizzazione di query OLAP in Synapse e SQL Server}

Nel pool SQL dedicato di Azure Synapse, l’ottimizzazione delle interrogazioni OLAP ruota attorno alla riduzione del \textit{data movement} e alla qualità delle stime dell’ottimizzatore. La scelta della distribuzione delle tabelle (e delle viste materializzate e degli intermedi persistiti) è il primo determinante. HASH sulle chiavi di \textit{join} ricorrenti consente co-locazione delle righe e piani con meno shuffle, ROUND\_ROBIN è neutro e si adotta solo quando non esiste una chiave naturale o per scenari transitori, poiché può aumentare gli scambi di dati durante le \textit{join} su grandi fatti e dimensioni (Microsoft, 2025 \cite{Microsoft2025}; Microsoft, 2024 \cite{Microsoft2024}).  L'utilità dei piani dipende inoltre da statistiche aggiornate: su Synapse è prassi creare/aggiornare statistiche istogrammatiche sulle colonne di filtro e di \textit{join} dopo i caricamenti \textit{bulk} o le trasformazioni massive, per evitare selettività errate e scelte subottimali di movimentazione (Microsoft, 2025 \cite{Microsoft2025}; Microsoft, 2022 \cite{Microsoft2022}). 
\\ \\
Per contenere i costi delle aggregazioni ripetute e dei ripartizionamenti, è efficace l’uso di CTAS (CREATE TABLE AS SELECT) per materializzare risultati intermedi già distribuiti in modo ottimale, nonché delle tabelle temporanee di sessione, che scrivono su \textit{storage} locale e riducono il traffico remoto durante \textit{pipeline} complesse (Microsoft, 2025 \cite{Microsoft2025}; Microsoft, 2022 \cite{Microsoft2022}).  A livello di formato fisico, il \textit{columnstore} è il \textit{default} nel \textit{data warehouse} MPP e rimane centrale anche nell’ecosistema SQL Server \textit{on-prem}/\textit{managed}: l’archiviazione per colonne consente elevate compressioni e scansioni vettoriali, risultando appropriata per fatti di grandi dimensioni e \textit{workload} analitici; il partizionamento temporale favorisce la gestione di finestre e operazioni di manutenzione (Microsoft, 2025)\cite{Microsoft2025}. 

\includesql{./adds/Viste_materializzate_OLAP_su_SQL_Server_e_Synapse/ottimizzazione_tutto}{Synapse: ciclo di ottimizzazione OLAP con CTAS, MV, STATISTICS, \textit{temp table}, EXPLAIN e DBCC OVERHEAD/REBUILD (esempio originale)}{lst:synapse-olap-ctas-mv-explain-dbcc}

Sul piano delle tecniche di risposta rapida, è utile distinguere \textit{result-set caching }e viste materializzate. La prima restituisce esiti identici per \textit{query} ripetute alla lettera, eliminando la rielaborazione ma offrendo riuso solo \textit{full-result}. Le seconde abilitano il riuso parziale tramite riscrittura, supportando varianti di predicati/\textit{roll-up} e restando efficaci anche quando la \textit{query} non coincide con la definizione della vista (Microsoft, 2022 \cite{Microsoft2022}; Microsoft, 2023 \cite{Microsoft2023}).  La diagnostica dei piani e delle opportunità di riscrittura si conduce con EXPLAIN (eventualmente con l’opzione WITH RECOMMENDATIONS) per osservare operatori, costi stimati e movimenti dati prima dell’esecuzione (Microsoft, 2024)\cite{Microsoft2024}.  Per le viste materializzate, l’\textit{overhead} incrementale derivante dai DML si misura con DBCC PDW\_SHOWMATERIALIZEDVIEWOVE RHEAD, che espone conteggi di \textit{tracking} e un \textit{overhead ratio} utile a programmare i REBUILD nelle finestre ETL, evitando degradazioni progressive della latenza (Microsoft, 2024)\cite{Microsoft2024}. 
\\ \\
In sintesi, un ciclo efficace su Synapse combina distribuzione coerente, statistiche curate, materializzazioni intermedie (CTAS/temporanee) e \textit{columnstore}, governando l’uso di \textit{cache} dei risultati rispetto alle viste materializzate e supportando le scelte con EXPLAIN e DBCC. Questi principi, per analogia, trovano riscontro nell’uso degli indici \textit{columnstore} anche in SQL Server per scenari del \textit{data warehouse}. (Microsoft, 2025)\cite{Microsoft2025}.  

\section{Tuning e monitoraggio: caso Synapse e SQL Server}

\subsection{Metodologia operativa di ottimizzazione}

La metodologia adottata segue un ciclo iterativo e riproducibile centrato su profilazione, progettazione, validazione e monitoraggio. In primo luogo, si profilano le interrogazioni più gravose mediante il piano stimato (EXPLAIN, in Synapse anche con l’opzione WITH RECOMMENDATIONS), così da individuare operatori dominanti, movimenti dati (\textit{shuffle}/\textit{broadcast}) e opportunità di riscrittura verso viste materializzate proposte dal motore. La profilazione definisce la \textit{baseline} prestazionale (tempi e varianza) e vincola le decisioni successive, garantendo tracciabilità metodologica coerente con il quadro del \textit{data warehousing} presentato nei capitoli precedenti (Microsoft, 2024a \cite{Microsoft2024a}; Vaisman \& Zimányi, 2022 \cite{VaismanZimanyi2022}). 
\\ \\
Sulla base dell’analisi, si progettano viste materializzate che catturano \textit{join} e aggregazioni condivise da più \textit{query} del \textit{workload}, privilegiando definizioni a massima riusabilità e minimizzando la cardinalità dei gruppi. In Synapse la scelta della distribuzione è cruciale per ridurre il \textit{data movement}: HASH sulle chiavi di \textit{join} ricorrenti quando possibile, ROUND\_ROBIN solo in assenza di una chiave naturale o per scenari transitori. In presenza di chiavi composite e skew si valuta la \textit{multi-column distribution} quando supportata. Le definizioni rispettano i vincoli formali già esposti (determinismo, funzioni ammesse, assenza di riferimenti ad altre viste), in modo da preservare la possibilità di riscrittura automatica e la sostenibilità della manutenzione (Microsoft, 2024b \cite{Microsoft2024b}; Vaisman \& Zimányi, 2022 \cite{VaismanZimanyi2022}).
\\ \\
Segue la validazione del comportamento dell’ottimizzatore. Dopo la creazione, si verifica che il piano indirizzi la \textit{query} verso la vista anche senza citarla nel testo SQL (\textit{auto-matching}), confermando l’effettiva sostituzione semantica dei sotto-piani di \textit{join}/aggregazione. In SQL Server il controllo è analogo per le viste indicizzate, con eventuale impiego prudente di \textit{hint} per casi particolari, come richiamato nella letteratura tecnica. L’obiettivo rimane il medesimo: garantire che l’ottimizzatore selezioni il piano con costo atteso minore a parità di semantica (Microsoft, 2024a \cite{Microsoft2024a}; Vaisman \& Zimányi, 2022 \cite{VaismanZimanyi2022}). 
\\ \\
La fase finale riguarda il monitoraggio e la \textit{governance}. In Synapse si misura l’\textit{overhead} incrementale con DBCC PDW\_SHOWMATERIALIZEDVIEWOVERHE AD e, al superamento di soglie operative (ad esempio l'aumento marcato del rapporto di \textit{overhead} o delle \textit{tracking rows}), si esegue un REBUILD programmato nelle finestre ETL per ripristinare l’efficienza di scansione. In parallelo si discrimina tra \textit{result-set caching} e \textit{materialized views}: la \textit{cache} è efficace per richieste ripetute identiche (riuso del risultato completo), mentre le viste permettono riuso parziale tramite riscrittura su \textit{pattern} condivisi e restano utili anche con predicati/\textit{roll-up} variabili. Le decisioni devono essere documentate e rese misurabili, predisponendo le metriche e gli strumenti di \ref{sec:622} (Microsoft, 2023a \cite{Microsoft2023a}; Microsoft, 2023b \cite{Microsoft2023b}; Microsoft, 2024b \cite{Microsoft2024b}; Vaisman \& Zimányi, 2022 \cite{VaismanZimanyi2022}).

\includesql{./adds/Viste_materializzate_OLAP_su_SQL_Server_e_Synapse/metodologia_operativa}{Synapse — ciclo operativo: EXPLAIN, MV con distribuzione HASH, validazione del \textit{rewrite}, monitoraggio \textit{overhead} e confronto con la \textit{result-set cache} (esempio originale)}{lst:synapse-workflow-621}

\subsection{Metriche di valutazione e strumenti di monitoraggio}\label{sec:622}

La valutazione degli effetti delle viste materializzate richiede un impianto metrico coerente con il carico OLAP e con i vincoli di aggiornamento dei dati (soglia massima di \textit{staleness}) e di manutenzione delle viste. Il punto di partenza è la misura dei tempi di risposta a parità di \textit{dataset} e parametri di esecuzione: si considerano media, mediana e varianza (o percentili) su un numero sufficiente di \textit{run}, istinguendo misure a \textit{cache} non inizializzata (\textit{cold cache}) e a \textit{cache} inizializzata (\textit{warm cache}) per evitare \textit{bias} da \textit{caching} transitorio. Queste statistiche danno conto sia del guadagno medio sia della stabilità delle latenze, che in \textit{data warehouse} è spesso un requisito contrattuale oltre che tecnico (Vaisman \& Zimányi, 2022 \cite{VaismanZimanyi2022}). 
\\ \\
Accanto ai tempi, in Synapse si monitora l’\textit{overhead} incrementale delle \textit{materialized view} tramite DBCC PDW\_SHOWMATERIALIZEDVIEWOVERHEAD, che espone conteggi di righe “tracciate” e un \textit{overhead\_ratio} sintetico. Tale rapporto cresce al crescere dei DML sulle tabelle di base e, oltre soglie operative definite dal team, tende a penalizzare le scansioni della vista. In questi casi si programma un REBUILD nelle finestre ETL per ripristinare l’efficienza. La disponibilità di questo indicatore consente di legare la decisione di manutenzione a una misura riproducibile e documentata dal fornitore (Microsoft, 2024a)\cite{Microsoft2024a}. 

\includesql{./adds/Viste_materializzate_OLAP_su_SQL_Server_e_Synapse/SQL_Server_columnstore}{SQL Server - cenni: stato dei \textit{rowgroup columnstore} e spazio per oggetto materializzato (esempio originale)}{lst:qlserver-kpi-622}

La pressione su spazio e I/O si rileva mediante DMV e procedure di sistema: l’occupazione effettiva delle viste e delle tabelle sottostanti si stima con viste dinamiche del \textit{pool} dedicato e, quando opportuno, con \textit{report} sintetici (ad esempio analoghi a \textit{sp\_spaceused} in ambienti SQL Server) per confrontare il costo di \textit{storage} rispetto al beneficio prestazionale. In parallelo, per scenari ibridi o cenni a SQL Server, è utile osservare anche la qualità delle strutture \textit{columnstore} (stato dei \textit{rowgroup}, compressione) e l’uso degli indici nel tempo, così da cogliere effetti indiretti della materializzazione sul piano fisico (Microsoft, 2024b \cite{Microsoft2024b}; Vaisman \& Zimányi, 2022 \cite{VaismanZimanyi2022}). 
\\ \\
Infine, l’impatto sui DML va esplicitato: si registrano \textit{throughput} e latenza dei carichi nelle finestre di ingestione, correlando eventuali regressioni con l’aumento dell’\textit{overhead} della vista e con il volume di aggiornamenti. L’insieme dei KPI (tempi, \textit{overhead\_ratio}, spazio e impatto DML) definisce un quadro di ROI operativo: il mantenimento della vista è conveniente quando il guadagno stabile in latenza eccede i costi di manutenzione e di \textit{storage}, come previsto dalle linee guida ufficiali per il \textit{tuning} delle \textit{materialized view} e dagli strumenti nativi di diagnostica del motore (Microsoft, 2024a \cite{Microsoft2024a}; Microsoft, 2024b \cite{Microsoft2024b}; Vaisman \& Zimányi, 2022 \cite{VaismanZimanyi2022}).

\subsection{Valutazione sperimentale su Transaction Processing Performance – Decision Support}

La letteratura tecnica e la documentazione ufficiale riportano valutazioni impostate su sottoinsiemi del \textit{benchmark} TPC-DS per rappresentare carichi decisionali con numerose \textit{join} e aggregazioni. In tali studi vengono selezionate interrogazioni con raggruppamenti su dimensioni temporali e di prodotto, in coerenza con schemi a stella tipici dei \textit{data warehouse}, così da massimizzare la confrontabilità tra misure di base ed interventi di ottimizzazione. L’adozione di TPC-DS consente di ancorare il disegno sperimentale a uno standard pubblico e riproducibile, con semantica di \textit{business} realistica e ampia varietà di piani candidati (TPC, 2021)\cite{TPC2021}. 
\\ \\
Per la \textit{baseline} vengono eseguite più misurazioni in condizioni di cache non inizializzata (\textit{cold cache}) e di \textit{cache} inizializzata (\textit{warm cache}), registrando media, mediana e varianza dei tempi di risposta e analizzando i piani stimati con EXPLAIN (Synapse) per individuare operatori dominanti e movimenti dati (\textit{shuffle}/\textit{broadcast}). Questa ispezione consente di isolare i colli di bottiglia e di identificare sotto-piani di \textit{join}/aggregazione suscettibili a calcolo anticipato tramite viste materializzate, in linea con le indicazioni fornite dal produttore (Microsoft, 2024)\cite{Microsoft2024}. 
\\ \\
Gli interventi descritti prevedono la definizione di una/due viste materializzate orientate a catturare aggregazioni riusate da più interrogazioni (ad esempio vendite per ProductID × MonthKey), con distribuzione HASH sulle chiavi di \textit{join} ricorrenti allo scopo di ridurre il movimento dati. L’effettivo impiego delle viste è verificato confrontando i piani stimati prima/dopo e accertando la riscrittura automatica dei sotto-piani verso l’oggetto materializzato, senza modificare il testo SQL applicativo (Microsoft, 2022–2023)\cite{Microsoft2022-2023}. Tale approccio è coerente con le linee guida che raccomandano di progettare la vista sulla congiunzione e sull’aggregazione condivise, richiedendo all’ottimizzatore il \textit{matching} trasparente quando le condizioni semantiche e fisiche lo consentono (Vaisman \& Zimányi, 2022)\cite{VaismanZimanyi2022}. 
\\ \\
I risultati riportati mostrano, per le \textit{query} bersaglio, una riduzione delle latenze e della variabilità, con benefici più marcati per granularità intermedie. In parallelo viene monitorato l’\textit{overhead} incrementale delle viste tramite DBCC PDW\_SHOWMATE RIALIZEDVIEWOVERHEAD e, al superamento di soglie operative, viene pianificato il REBUILD per ripristinare l’efficienza di scansione. Questa procedura lega la decisione di manutenzione a un indicatore nativo e documentato, mitigando il rischio di degrado progressivo (Microsoft, 2023)\cite{Microsoft2023}. Nel complesso, i casi TPC-DS convergono sull’evidenza che la materializzazione mirata di aggregazioni condivise, con distribuzione coerente alle chiavi di \textit{join}, produce un rapporto costo/beneficio favorevole quando i guadagni stabili in latenza superano i costi di manutenzione e di spazio, in accordo con le linee guida su \textit{tuning} con viste materializzate e con l’uso sistematico di EXPLAIN per la validazione \textit{ex ante} dei piani (Microsoft, 2022–2024 \cite{Microsoft2022-2024}; Vaisman \& Zimányi, 2022 \cite{VaismanZimanyi2022}). 
\\ \\
Le scelte che massimizzano il beneficio dipendono dallo strato fisico delineato nel Capitolo \ref{cap4} (distribuzione, partizionamento, \textit{columnstore}) e applicano i criteri di selezione/manutenzione formalizzati nel Capitolo \ref{cap5}. I \textit{benchmark} TPC-DS permettono una valutazione quantitativa degli effetti di tali scelte in condizioni operativi replicabili.

\includesql{./adds/Viste_materializzate_OLAP_su_SQL_Server_e_Synapse/tpcds}{Synapse - Valutazione TPC-DS: \textit{baseline}, MV mirata, validazione con \texttt{EXPLAIN}, KPI temporali e \textit{overhead} (esempio originale)}{lst:tpcds-eval-synapse}